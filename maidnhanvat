/****************************************************
 * T√äN D·ª∞ √ÅN: REMOTE SMART ESP32-S3 (C√ì OTA + SINRIC PRO + NTP)
 * T√çNH NƒÇNG:
 * - PHI√äN B·∫¢N v7: (Theo y√™u c·∫ßu ng∆∞·ªùi d√πng)
 * - H·∫πn gi·ªù Web cho 3 CH√ÇN (4, 5, 7).
 * - M·ªói ch√¢n c√≥ 3 L·ªäCH H·∫∏N GI·ªú ƒë·ªôc l·∫≠p.
 * - ƒê·ªô ch√≠nh x√°c t·ªõi GI·ªú:PH√öT:GI√ÇY (H:M:S).
 * - Ch√¢n 16 (PIN_4) ch·ªâ ƒëi·ªÅu khi·ªÉn b·∫±ng tay.
 * - L·ªãch h·∫πn gi·ªù ƒë∆∞·ª£c L∆ØU v√†o Preferences (d∆∞·ªõi d·∫°ng t·ªïng s·ªë gi√¢y).
 * - T·ª± ƒë·ªông x·ª≠ l√Ω l·ªãch "trong ng√†y" v√† "qua ƒë√™m".
 *
 * KI·∫æN TR√öC L√ïI:
 * - L√µi 1 (Core 1): Ch·ªâ ch·∫°y Web Server.
 * - L√µi 0 (Core 0): Ch·∫°y Task qu·∫£n l√Ω Internet (Sinric, NTP) v√†
 * Task logic t·ª± ƒë·ªông (ƒë·ªçc l·ªãch h·∫πn gi·ªù ƒë√£ l∆∞u).
 ****************************************************/

#include <WiFi.h>
#include <WebServer.h>
#include <DNSServer.h>
#include <HTTPClient.h>
#include <Update.h>
#include <Preferences.h>
#include <WiFiClientSecure.h>
#include <SinricPro.h>
#include <SinricProSwitch.h>
#include <time.h> // Th√™m th∆∞ vi·ªán NTP

Preferences prefs;

// === BI·∫æN QU·∫¢N L√ù CHO L√ïI 0 ===
TaskHandle_t NetworkTaskHandle; 
bool isInternetActive = false; 
bool sinricStarted = false; 
// =============================

// ‚öôÔ∏è WiFi
const char* ap_ssid = "Remote Smart";
const char* ap_pass = "12345678";
String saved_ssid = "";
String saved_pass = "";

// ‚öôÔ∏è Sinric Pro (ch·ªâ 3 thi·∫øt b·ªã)
#define APP_KEY       "90c7281e-d20e-4991-9e16-e69dbcd53548"
#define APP_SECRET    "0209ebce-d065-46ff-8d0f-4b975fc8f189-822cdecd-d3a7-4f79-a4d5-919214ece972"
#define SWITCH_ID_1 "68ff3757ba649e246c134f80"
#define SWITCH_ID_2 "68ff55d7ba649e246c135b09"
#define SWITCH_ID_3 "68ff560facd5d3d66b56ba0a"

// ‚öôÔ∏è GPIO
#define PIN_1 4
#define PIN_2 5
#define PIN_3 7
#define PIN_4 16
#define PIN_STOP 8
#define PIN_RESET 9
#define PIN_OTA 21

// ‚öôÔ∏è Bi·∫øn tr·∫°ng th√°i
bool state1, state2, state3, state4;
bool stopAll = false;
unsigned long startTime = 0;

// Bi·∫øn cho NTP
const char* ntpServer = "pool.ntp.org";
const long gmtOffset_sec = 7 * 3600; // UTC+7
const int daylightOffset_sec = 0;

// Bi·∫øn cho logic 2s/2s (c·ªßa Ch√¢n 4)
// (LOGIC N√ÄY ƒê√É B·ªä X√ìA THEO Y√äU C·∫¶U M·ªöI, THAY B·∫∞NG L·ªäCH H:M:S)

// ‚öôÔ∏è Bi·∫øn Debounce cho n√∫t v·∫≠t l√Ω
unsigned long lastStopButtonTime = 0;
unsigned long lastResetButtonTime = 0;
const unsigned long DEBOUNCE_DELAY = 100; // 100ms

// ‚öôÔ∏è Bi·∫øn Preferences
const char* PREF_NAMESPACE = "smart_config";
const char* KEY_STOP_ALL = "stop_state";
const char* KEY_WIFI_SSID = "wifi_ssid";
const char* KEY_WIFI_PASS = "wifi_pass";

// === [M·ªöI] BI·∫æN V√Ä KEY CHO H·∫∏N GI·ªú (H:M:S) ===
// Bi·∫øn to√†n c·ª•c (d·∫°ng long, t√≠nh b·∫±ng T·ªîNG S·ªê GI√ÇY)
// 3 L·ªãch cho Ch√¢n 4 (PIN_1)
long p1_s1_start_s, p1_s1_end_s;
long p1_s2_start_s, p1_s2_end_s;
long p1_s3_start_s, p1_s3_end_s;
// 3 L·ªãch cho Ch√¢n 5 (PIN_2)
long p2_s1_start_s, p2_s1_end_s;
long p2_s2_start_s, p2_s2_end_s;
long p2_s3_start_s, p2_s3_end_s;
// 3 L·ªãch cho Ch√¢n 7 (PIN_3)
long p3_s1_start_s, p3_s1_end_s;
long p3_s2_start_s, p3_s2_end_s;
long p3_s3_start_s, p3_s3_end_s;
// ============================================

// ‚öôÔ∏è Web & DNS
WebServer server(80);
DNSServer dns;

// ‚öôÔ∏è Link OTA
const char* firmware_url = "https://github.com/chuyengamy28-tech/firmware/raw/main/update.bin";

// ====================== STATE PERSISTENCE ======================
void saveState() {
    prefs.begin(PREF_NAMESPACE, false);
    prefs.putBool(KEY_STOP_ALL, stopAll);
    prefs.end();
    Serial.printf("[PREF] ƒê√£ l∆∞u stopAll = %s\n", stopAll ? "TRUE" : "FALSE");
}

void loadState() {
    prefs.begin(PREF_NAMESPACE, true);
    stopAll = prefs.getBool(KEY_STOP_ALL, false);
    prefs.end();
    Serial.printf("[PREF] ƒê√£ t·∫£i stopAll = %s\n", stopAll ? "TRUE" : "FALSE");
}

// === [M·ªöI] H√ÄM T·∫¢I L·ªäCH H·∫∏N GI·ªú (v7) ===
void loadSchedules() {
    prefs.begin(PREF_NAMESPACE, true); // M·ªü ·ªü ch·∫ø ƒë·ªô read-only
    
    // T·∫£i 3 l·ªãch Ch√¢n 4 (PIN_1)
    p1_s1_start_s = prefs.getLong("p1s1_on", 0); p1_s1_end_s = prefs.getLong("p1s1_off", 0);
    p1_s2_start_s = prefs.getLong("p1s2_on", 0); p1_s2_end_s = prefs.getLong("p1s2_off", 0);
    p1_s3_start_s = prefs.getLong("p1s3_on", 0); p1_s3_end_s = prefs.getLong("p1s3_off", 0);
    
    // T·∫£i 3 l·ªãch Ch√¢n 5 (PIN_2)
    p2_s1_start_s = prefs.getLong("p2s1_on", 0); p2_s1_end_s = prefs.getLong("p2s1_off", 0);
    p2_s2_start_s = prefs.getLong("p2s2_on", 0); p2_s2_end_s = prefs.getLong("p2s2_off", 0);
    p2_s3_start_s = prefs.getLong("p2s3_on", 0); p2_s3_end_s = prefs.getLong("p2s3_off", 0);
    
    // T·∫£i 3 l·ªãch Ch√¢n 7 (PIN_3)
    p3_s1_start_s = prefs.getLong("p3s1_on", 0); p3_s1_end_s = prefs.getLong("p3s1_off", 0);
    p3_s2_start_s = prefs.getLong("p3s2_on", 0); p3_s2_end_s = prefs.getLong("p3s2_off", 0);
    p3_s3_start_s = prefs.getLong("p3s3_on", 0); p3_s3_end_s = prefs.getLong("p3s3_off", 0);

    prefs.end();
    Serial.println("[SCHED] ƒê√£ t·∫£i l·ªãch h·∫πn gi·ªù H:M:S t·ª´ Preferences.");
}

// ====================== NTP Setup ======================
void initTime() {
    configTime(gmtOffset_sec, daylightOffset_sec, ntpServer);
    Serial.println("[NTP] ƒê√£ c·∫•u h√¨nh NTP (UTC+7)");
}

// ====================== C√ÅC TRANG WEB ======================

// === [M·ªöI] TRANG WEB C√ÄI ƒê·∫∂T H·∫∏N GI·ªú (v7 - H:M:S) ===
void handleSchedulePage() {
    String html = "<!DOCTYPE html><html><head><meta charset='utf-8'>";
    html += "<meta name='viewport' content='width=device-width,initial-scale=1'>";
    html += "<title>C√†i ƒë·∫∑t H·∫πn gi·ªù</title><style>";
    html += "body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Helvetica,Arial,sans-serif;text-align:center;background:#f0f2f5;margin:0;padding:15px;}";
    html += "h3{color:#333;margin-top:0;} a{text-decoration:none;}";
    html += "form{max-width:500px;margin:0 auto 15px auto;padding:15px;background:white;border-radius:12px;box-shadow:0 2px 8px rgba(0,0,0,0.08);}";
    html += ".timegrid{display:grid;grid-template-columns:30px 30px 30px;gap:5px;justify-content:center;}";
    html += ".timegrid input{width:100%;padding:8px 0;text-align:center;border:1px solid #ccc;border-radius:5px;}";
    html += ".schedgrid{display:grid;grid-template-columns:1fr 1fr;gap:10px;align-items:center;margin-top:10px;}";
    html += ".schedgrid label{font-weight:600;font-size:0.9em;margin:0;}";
    html += ".pin_section h4{color:#1976D2;margin:15px 0 10px 0;border-bottom:1px solid #eee;padding-bottom:5px;}";
    html += ".sched_item h5{margin:10px 0 5px 0;font-size:0.95em;color:#555;}";
    html += "button,.btn{width:auto;min-width:120px;padding:0 15px;height:45px;font-size:16px;font-weight:600;margin:5px;border:none;border-radius:10px;color:white;cursor:pointer;transition:transform 0.1s ease;}";
    html += "button:active,.btn:active{transform:scale(0.95);}";
    html += "button[type='submit']{background-color:#4CAF50;width:100%;margin-top:15px;}"; // N√∫t L∆∞u
    html += ".home{background-color:#555;display:inline-block;line-height:45px;}"; // N√∫t Quay v·ªÅ
    html += ".note{font-size:0.9em;color:#777;margin-top:15px;}";
    html += "</style></head><body>";
    html += "<h3>C√ÄI ƒê·∫∂T H·∫∏N GI·ªú (H:M:S)</h3>";
    html += "<p class='note'>Nh·∫≠p Gi·ªù(0-23), Ph√∫t(0-59), Gi√¢y(0-59).<br>ƒê·ªÉ B·∫≠t = T·∫Øt (v√≠ d·ª• 0:0:0) ƒë·ªÉ v√¥ hi·ªáu h√≥a l·ªãch ƒë√≥.</p>";

    // Form
    html += "<form action='/save_hengio' method='POST'>";

    // === Lambda helper (gi√∫p code g·ªçn) ===
    // 1. T√°ch s·ªë gi√¢y t·ªïng th√†nh H, M, S
    auto getHMS = [](long totalSeconds) {
        int h = totalSeconds / 3600;
        totalSeconds %= 3600;
        int m = totalSeconds / 60;
        int s = totalSeconds % 60;
        return String(h) + "," + String(m) + "," + String(s);
    };

    // 2. V·∫Ω 1 l·ªãch (6 √¥ nh·∫≠p li·ªáu)
    auto addScheduleInputs = [&](String prefix, long start_s, long end_s) {
        String startHMS = getHMS(start_s);
        String endHMS = getHMS(end_s);
        int h_on, m_on, s_on, h_off, m_off, s_off;
        sscanf(startHMS.c_str(), "%d,%d,%d", &h_on, &m_on, &s_on);
        sscanf(endHMS.c_str(), "%d,%d,%d", &h_off, &m_off, &s_off);

        html += "<div class='schedgrid'>";
        // C·ªôt B·∫¨T
        html += "<div><label>B·∫¨T (H:M:S)</label><div class='timegrid'>";
        html += "<input type='number' min='0' max='23' name='" + prefix + "_h_on' value='" + h_on + "'>";
        html += "<input type='number' min='0' max='59' name='" + prefix + "_m_on' value='" + m_on + "'>";
        html += "<input type='number' min='0' max='59' name='" + prefix + "_s_on' value='" + s_on + "'>";
        html += "</div></div>";
        // C·ªôt T·∫ÆT
        html += "<div><label>T·∫ÆT (H:M:S)</label><div class='timegrid'>";
        html += "<input type='number' min='0' max='23' name='" + prefix + "_h_off' value='" + h_off + "'>";
        html += "<input type='number' min='0' max='59' name='" + prefix + "_m_off' value='" + m_off + "'>";
        html += "<input type='number' min='0' max='59' name='" + prefix + "_s_off' value='" + s_off + "'>";
        html += "</div></div>";
        html += "</div>"; // .schedgrid
    };

    // --- Th√™m 3 Ch√¢n ---
    html += "<div class='pin_section'>";
    html += "<h4>·ªî c·∫Øm 1 (t√™n m√°y)</h4>";
    html += "<h5>L·ªãch 1</h5>"; addScheduleInputs("p1s1", p1_s1_start_s, p1_s1_end_s);
    html += "<h5>L·ªãch 2</h5>"; addScheduleInputs("p1s2", p1_s2_start_s, p1_s2_end_s);
    html += "<h5>L·ªãch 3</h5>"; addScheduleInputs("p1s3", p1_s3_start_s, p1_s3_end_s);
    html += "</div>";

    html += "<div class='pin_section'>";
    html += "<h4>·ªî c·∫Øm 2 (t√™n m√°y)</h4>";
    html += "<h5>L·ªãch 1</h5>"; addScheduleInputs("p2s1", p2_s1_start_s, p2_s1_end_s);
    html += "<h5>L·ªãch 2</h5>"; addScheduleInputs("p2s2", p2_s2_start_s, p2_s2_end_s);
    html += "<h5>L·ªãch 3</h5>"; addScheduleInputs("p2s3", p2_s3_start_s, p2_s3_end_s);
    html += "</div>";

    html += "<div class='pin_section'>";
    html += "<h4>·ªî c·∫Øm 3 (t√™n m√°y)</h4>";
    html += "<h5>L·ªãch 1</h5>"; addScheduleInputs("p3s1", p3_s1_start_s, p3_s1_end_s);
    html += "<h5>L·ªãch 2</h5>"; addScheduleInputs("p3s2", p3_s2_start_s, p3_s2_end_s);
    html += "<h5>L·ªãch 3</h5>"; addScheduleInputs("p3s3", p3_s3_start_s, p3_s3_end_s);
    html += "</div>";

    html += "<p class='note' style='color:red;font-weight:bold;'>Ch√¢n 16 (PIN_4) ch·ªâ ƒëi·ªÅu khi·ªÉn b·∫±ng tay.</p>";

    html += "<button type='submit'>L∆∞u C√†i ƒê·∫∑t</button>";
    html += "</form>";
    html += "<a href='/' class='btn home'>Quay v·ªÅ trang ch·ªß</a>";
    html += "</body></html>";
    server.send(200, "text/html", html);
}

// === [M·ªöI] H√ÄM X·ª¨ L√ù L∆ØU H·∫∏N GI·ªú (v7 - H:M:S) ===
void handleSaveSchedule() {
    Serial.println("[WEB] ƒêang nh·∫≠n l·ªãch h·∫πn gi·ªù H:M:S m·ªõi...");

    // Lambda helper: L·∫•y H, M, S t·ª´ form v√† tr·∫£ v·ªÅ T·ªîNG S·ªê GI√ÇY
    auto getSecondsFromForm = [&](String prefix, String type) {
        long h = server.arg(prefix + "_h_" + type).toInt();
        long m = server.arg(prefix + "_m_" + type).toInt();
        long s = server.arg(prefix + "_s_" + type).toInt();
        return (h * 3600) + (m * 60) + s;
    };

    // 1. ƒê·ªçc v√† chuy·ªÉn ƒë·ªïi
    p1_s1_start_s = getSecondsFromForm("p1s1", "on"); p1_s1_end_s = getSecondsFromForm("p1s1", "off");
    p1_s2_start_s = getSecondsFromForm("p1s2", "on"); p1_s2_end_s = getSecondsFromForm("p1s2", "off");
    p1_s3_start_s = getSecondsFromForm("p1s3", "on"); p1_s3_end_s = getSecondsFromForm("p1s3", "off");
    
    p2_s1_start_s = getSecondsFromForm("p2s1", "on"); p2_s1_end_s = getSecondsFromForm("p2s1", "off");
    p2_s2_start_s = getSecondsFromForm("p2s2", "on"); p2_s2_end_s = getSecondsFromForm("p2s2", "off");
    p2_s3_start_s = getSecondsFromForm("p2s3", "on"); p2_s3_end_s = getSecondsFromForm("p2s3", "off");
    
    p3_s1_start_s = getSecondsFromForm("p3s1", "on"); p3_s1_end_s = getSecondsFromForm("p3s1", "off");
    p3_s2_start_s = getSecondsFromForm("p3s2", "on"); p3_s2_end_s = getSecondsFromForm("p3s2", "off");
    p3_s3_start_s = getSecondsFromForm("p3s3", "on"); p3_s3_end_s = getSecondsFromForm("p3s3", "off");

    // 2. L∆∞u v√†o Preferences
    prefs.begin(PREF_NAMESPACE, false); // M·ªü ch·∫ø ƒë·ªô read-write
    prefs.putLong("p1s1_on", p1_s1_start_s); prefs.putLong("p1s1_off", p1_s1_end_s);
    prefs.putLong("p1s2_on", p1_s2_start_s); prefs.putLong("p1s2_off", p1_s2_end_s);
    prefs.putLong("p1s3_on", p1_s3_start_s); prefs.putLong("p1s3_off", p1_s3_end_s);
    
    prefs.putLong("p2s1_on", p2_s1_start_s); prefs.putLong("p2s1_off", p2_s1_end_s);
    prefs.putLong("p2s2_on", p2_s2_start_s); prefs.putLong("p2s2_off", p2_s2_end_s);
    prefs.putLong("p2s3_on", p2_s3_start_s); prefs.putLong("p2s3_off", p2_s3_end_s);
    
    prefs.putLong("p3s1_on", p3_s1_start_s); prefs.putLong("p3s1_off", p3_s1_end_s);
    prefs.putLong("p3s2_on", p3_s2_start_s); prefs.putLong("p3s2_off", p3_s2_end_s);
    prefs.putLong("p3s3_on", p3_s3_start_s); prefs.putLong("p3s3_off", p3_s3_end_s);
    prefs.end();

    Serial.println("[SCHED] ƒê√£ l∆∞u 18 m·ªëc H:M:S v√†o Preferences.");

    // 3. G·ª≠i th√¥ng b√°o v√† chuy·ªÉn h∆∞·ªõng
    String html = "<html><head><meta charset='utf-8'><title>ƒêang l∆∞u</title>";
    html += "<meta http-equiv='refresh' content='2;url=/'></head>"; // T·ª± chuy·ªÉn h∆∞·ªõng sau 2s
    html += "<body><p style='font-family:sans-serif;text-align:center;margin-top:30px;font-size:1.2em;'>";
    html += "‚úÖ ƒê√£ l∆∞u h·∫πn gi·ªù H:M:S!<br>ƒêang quay v·ªÅ trang ch·ªß...</p></body></html>";
    server.send(200, "text/html", html);
}


// --- C√°c trang WiFi (Gi·ªØ nguy√™n) ---
void handleWifiSettings() {
    String html = "<!DOCTYPE html><html><head><meta charset='utf-8'>";
    html += "<meta name='viewport' content='width=device-width,initial-scale=1'>";
    html += "<title>C√†i ƒë·∫∑t WiFi</title><style>";
    html += "body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Helvetica,Arial,sans-serif;text-align:center;background:#f0f2f5;margin:0;padding:15px;}";
    html += "h3{color:#333;margin-top:0;}";
    html += "a{text-decoration:none;}";
    html += "form{max-width:350px;margin:0 auto;padding:20px;background:white;border-radius:12px;box-shadow:0 2px 8px rgba(0,0,0,0.08);}";
    html += "input[type='text'],input[type='password'],select{width:100%;box-sizing:border-box;padding:12px;margin:10px 0;border:1px solid #ccc;border-radius:8px;font-size:16px;}";
    html += "button,.btn{width:auto;min-width:120px;padding:0 15px;height:45px;font-size:16px;font-weight:600;margin:5px;border:none;border-radius:10px;color:white;cursor:pointer;transition:transform 0.1s ease;}";
    html += "button:active,.btn:active{transform:scale(0.95);}";
    html += "button[type='submit']{background-color:#2196F3;width:100%;}"; // N√∫t L∆∞u
    html += ".scan{background-color:#FF9800;}"; // N√∫t Qu√©t
    html += ".home{background-color:#555;display:inline-block;line-height:45px;margin-top:15px;}";
    html += "</style>";
    html += "</head><body>";
    html += "<form action='/savewifi' method='POST'>";
    html += "<h3>C√ÄI ƒê·∫∂T WIFI</h3>";
    if (WiFi.status() == WL_CONNECTED) {
        html += "<p style='color:green;'>ƒêang k·∫øt n·ªëi: <strong>" + WiFi.SSID() + "</strong></p>";
    } else {
        html += "<p style='color:red;'>Ch∆∞a k·∫øt n·ªëi WiFi</p>";
    }
    html += "<input id='ssid' name='ssid' type='text' placeholder='T√™n WiFi (SSID)' value='" + saved_ssid + "'>";
    html += "<input name='pass' type='password' placeholder='M·∫≠t kh·∫©u WiFi'>";
    html += "<button type='submit'>L∆∞u & Kh·ªüi ƒë·ªông l·∫°i</button>";
    html += "</form>";
    html += "<form action='/wifi_scan_results' method='GET' style='margin-top:15px;padding:15px;'>";
    html += "<h4 style='margin:15px 0 5px 0;'>Kh√¥ng nh·ªõ t√™n?</h4>";
    html += "<button class='scan' type='submit'>Qu√©t WiFi ƒë·ªÉ ch·ªçn</button>";
    html += "</form>";
    html += "<a href='/' class='btn home'>Quay v·ªÅ trang ch·ªß</a>";
    html += "</body></html>";
    server.send(200, "text/html", html);
}

void handleWifiScanResults() {
    String html = "<!DOCTYPE html><html><head><meta charset='utf-8'>";
    html += "<meta name='viewport' content='width=device-width,initial-scale=1'>";
    html += "<title>Qu√©t WiFi</title><style>";
    html += "body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Helvetica,Arial,sans-serif;text-align:center;background:#f0f2f5;margin:0;padding:15px;}";
    html += "h3{color:#333;margin-top:0;}";
    html += "a{text-decoration:none;}";
    html += "form{max-width:350px;margin:0 auto;padding:20px;background:white;border-radius:12px;box-shadow:0 2px 8px rgba(0,0,0,0.08);}";
    html += "input[type='text'],input[type='password'],select{width:100%;box-sizing:border-box;padding:12px;margin:10px 0;border:1px solid #ccc;border-radius:8px;font-size:16px;}";
    html += "button,.btn{width:auto;min-width:120px;padding:0 15px;height:45px;font-size:16px;font-weight:600;margin:5px;border:none;border-radius:10px;color:white;cursor:pointer;transition:transform 0.1s ease;}";
    html += "button:active,.btn:active{transform:scale(0.95);}";
    html += ".scan{background-color:#FF9800;}"; // N√∫t Qu√©t
    html += ".home{background-color:#555;display:inline-block;line-height:45px;margin-top:15px;}";
    html += "h4{margin:15px 0 5px 0;}";
    html += "</style>";
    html += "<script>";
    html += "function sel(v){ var el = document.getElementById('selected_ssid_text'); if(el) el.innerHTML = 'ƒê√£ ch·ªçn: <strong>' + v + '</strong><br>Quay l·∫°i trang tr∆∞·ªõc ƒë·ªÉ L∆∞u.'; }";
    html += "</script>";
    html += "</head><body>";
    html += "<div style='max-width:350px;margin:0 auto;'>";
    html += "<h3>K·∫æT QU·∫¢ QU√âT WIFI</h3>";
    html += "<p>ƒêang qu√©t... vui l√≤ng ch·ªù.</p>";
    html += "<form action='/wifi_scan_results' method='GET' style='padding:15px;background:white;border-radius:12px;box-shadow:0 2px 8px rgba(0,0,0,0.08);'>";
    html += "<button class='scan' type='submit'>Qu√©t l·∫°i</button>";
    Serial.println("[WIFI] T·∫°m ng·∫Øt STA ƒë·ªÉ ∆∞u ti√™n qu√©t...");
    WiFi.disconnect();
    delay(100);
    Serial.println("[WIFI] B·∫Øt ƒë·∫ßu qu√©t m·∫°ng...");
    int n = WiFi.scanNetworks();
    Serial.printf("[WIFI] Qu√©t xong, t√¨m th·∫•y %d m·∫°ng.\n", n);
    Serial.println("[WIFI] Kh·ªüi ƒë·ªông l·∫°i k·∫øt n·ªëi STA...");
    if (saved_ssid.length() > 0) {
         WiFi.begin(saved_ssid.c_str(), saved_pass.c_str());
    }
    if (n > 0) {
        html += "<h4>T√¨m th·∫•y " + String(n) + " m·∫°ng:</h4>";
        html += "<select onchange='sel(this.value)'>";
        html += "<option value=''>-- Ch·ªçn m·∫°ng --</option>";
        for (int i = 0; i < n; ++i) {
            html += "<option value='" + WiFi.SSID(i) + "'>" + WiFi.SSID(i) + " (" + WiFi.RSSI(i) + "dBm)</option>";
        }
        html += "</select>";
        html += "<p id='selected_ssid_text' style='margin-top:10px;color:green;'></p>";
    } else {
        html += "<p>Kh√¥ng t√¨m th·∫•y m·∫°ng WiFi n√†o.</p>";
    }
    html += "</form>";
    html += "<a href='/wifi' class='btn home'>Quay l·∫°i C√†i ƒë·∫∑t</a>";
    html += "</div></body></html>";
    server.send(200, "text/html", html);
}

void handleSaveWifi() {
    String ssid = server.arg("ssid");
    String pass = server.arg("pass");
    Serial.println("[WIFI] ƒêang l∆∞u c√†i ƒë·∫∑t WiFi m·ªõi...");
    Serial.println("SSID: " + ssid);
    prefs.begin(PREF_NAMESPACE, false);
    prefs.putString(KEY_WIFI_SSID, ssid);
    prefs.putString(KEY_WIFI_PASS, pass);
    prefs.end();
    String html = "<html><head><meta charset='utf-8'><title>ƒêang l∆∞u</title>";
    html += "<meta http-equiv='refresh' content='5;url=/'></head>"; // T·ª± chuy·ªÉn h∆∞·ªõng sau 5s
    html += "<body><p>ƒê√£ l∆∞u WiFi! ƒêang kh·ªüi ƒë·ªông l·∫°i...</p></body></html>";
    server.send(200, "text/html", html);
    delay(2000);
    ESP.restart();
}

// --- TRANG CH·ª¶ (Gi·ªØ nguy√™n) ---
String htmlPage() {
    String timeStr = "ƒêang ch·ªù ƒë·ªìng b·ªô gi·ªù...";
    if (isInternetActive) {
      struct tm timeinfo;
      time_t now;
      time(&now);
      localtime_r(&now, &timeinfo);
      if (timeinfo.tm_year > (2000 - 1900)) { // Ki·ªÉm tra gi·ªù h·ª£p l·ªá
          char timeBuffer[50];
          strftime(timeBuffer, 50, "%H:%M:%S | %d/%m/%Y", &timeinfo);
          timeStr = String(timeBuffer);
      }
    }

    String html = "<!DOCTYPE html><html><head><meta charset='utf-8'>";
    html += "<meta name='viewport' content='width=device-width,initial-scale=1'>";
    html += "<title>Remote Smart</title><style>";
    html += "body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Helvetica,Arial,sans-serif;text-align:center;background:#f0f2f5;margin:0;padding:15px;}";
    html += "h3{color:#333;}";
    html += "a{text-decoration:none;}";
    html += ".container{max-width:800px;margin:0 auto;}";
    html += ".status{margin-bottom:20px;padding:15px;background:#fff;border-radius:12px;box-shadow:0 2px 8px rgba(0,0,0,0.08);line-height:1.7;text-align:left;}";
    html += ".status strong{color:#555;}";
    html += ".grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(140px,1fr));gap:15px;margin-bottom:20px;}";
    html += ".card{background:#fff;padding:15px;border-radius:12px;box-shadow:0 2px 8px rgba(0,0,0,0.08);display:flex;flex-direction:column;justify-content:space-between;}";
    html += ".card h4{margin:0 0 10px 0;color:#333;font-size:1em;}";
    html += "button,.btn{width:100%;height:45px;font-size:16px;font-weight:600;margin:5px 0 0 0;border:none;border-radius:10px;color:white;cursor:pointer;transition:transform 0.1s ease;}";
    html += "button:active,.btn:active{transform:scale(0.95);}";
    html += ".on{background-color:#4CAF50;}";
    html += ".off{background-color:#f44336;}";
    html += ".control{background-color:#2196F3;}";
    html += ".ota{background-color:#FF9800;}"; // M√†u cam
    html += ".wifi{background-color:#555;}"; // M√†u x√°m
    html += "</style></head><body>";

    html += "<div class='container'>";
    html += "<h3>H·ªÜ TH·ªêNG ƒêI·ªÄU KHI·ªÇN</h3>";

    // --- Card Tr·∫°ng th√°i ---
    html += "<div class='status'>";
    if (WiFi.status() == WL_CONNECTED) {
        html += "<strong>WIFI: </strong><span style='color:green;'>" + WiFi.SSID() + " (" + WiFi.localIP().toString() + ")</span><br>";
        if (!isInternetActive) {
            html += "<strong>INTERNET: </strong><span style='color:orange;'>ƒêang ki·ªÉm tra (NTP)...</span><br>";
        } else {
             if (!sinricStarted) {
                html += "<strong>INTERNET: </strong><span style='color:orange;'>ƒêang k·∫øt n·ªëi Sinric...</span><br>";
             } else {
                if (SinricPro.isConnected()) {
                   html += "<strong>INTERNET: </strong><span style='color:green;'>ƒê√£ k·∫øt n·ªëi (Sinric/NTP)</span><br>";
                } else {
                   html += "<strong>INTERNET: </strong><span style='color:red;'>M·∫•t k·∫øt n·ªëi Sinric!</span><br>";
                }
             }
        }
    } else {
        html += "<strong>WIFI: </strong><span style='color:red;'>Ch∆∞a k·∫øt n·ªëi (AP: " + WiFi.softAPIP().toString() + ")</span><br>";
    }
    html += "<strong>GI·ªú NTP: </strong>" + timeStr + "<br>";
    String status_text = stopAll ? "<span style='color:#f44336;'>ƒêANG D·ª™NG</span>" : "<span style='color:#4CAF50;'>ƒêANG CH·∫†Y</span>";
    html += "<strong>T·ª∞ ƒê·ªòNG: </strong>" + status_text + "</div>";

    // --- L∆∞·ªõi c√°c n√∫t ---
    html += "<div class='grid'>";

    auto addBtnCard = [&](String name, bool state, String url, String cssClass = "") {
        String cls = cssClass.isEmpty() ? (state ? "on" : "off") : cssClass;
        String label = (cssClass == "control" || cssClass == "ota" || cssClass == "wifi") ? name : (state ? "ON" : "OFF");
        html += "<div class='card'>";
        html += "<h4>" + name + "</h4>";
        html += "<button class='" + cls + "' onclick=\"location.href='" + url + "'\">" + label + "</button>";
        html += "</div>";
    };

    addBtnCard("·ªî c·∫Øm 1 (t√™n m√°y)", state1, "/toggle1");
    addBtnCard("·ªî c·∫Øm 2 (t√™n m√°y)", state2, "/toggle2");
    addBtnCard("·ªî c·∫Øm 3 (t√™n m√°y)", state3, "/toggle3");
    addBtnCard("·ªî c·∫Øm 4 (t√™n m√°y)", state4, "/toggle4"); // V·∫´n hi·ªÉn th·ªã

    addBtnCard(stopAll ? "B·∫≠t t·ª± ƒë·ªông" : "D·ª´ng t·ª± ƒë·ªông", stopAll, "/toggleStop", "control");
    addBtnCard("Kh·ªüi ƒë·ªông l·∫°i", false, "/resetAuto", "control");
    
    // === [M·ªöI] TH√äM N√öT H·∫∏N GI·ªú ===
    addBtnCard("C√†i ƒë·∫∑t H·∫πn gi·ªù", false, "/hengio", "ota"); // D√πng m√†u cam
    
    addBtnCard("C√†i ƒë·∫∑t WiFi", false, "/wifi", "wifi"); // D√πng m√†u x√°m

    html += "</div>"; // ƒê√≥ng .grid
    
    // Th√™m n√∫t OTA (t√°ch ri√™ng v√¨ n√≥ kh√¥ng v·ª´a v√†o l∆∞·ªõi 8)
    html += "<div class='grid' style='grid-template-columns:1fr;'>";
    addBtnCard("C·∫≠p nh·∫≠t FW", false, "/otaUpdate", "ota");
    html += "</div>";
    
    html += "</div>"; // ƒê√≥ng .container
    html += "</body></html>";
    return html;
}

// ====================== OTA ======================
void performOTA() {
    if (WiFi.status() != WL_CONNECTED) {
        Serial.println("‚ùå Kh√¥ng c√≥ WiFi ƒë·ªÉ OTA");
        return;
    }
    WiFiClientSecure client;
    client.setInsecure();
    HTTPClient https;
    Serial.println("üîó K·∫øt n·ªëi ƒë·∫øn GitHub...");
    if (!https.begin(client, firmware_url)) {
        Serial.println("‚ùå Kh√¥ng th·ªÉ b·∫Øt ƒë·∫ßu k·∫øt n·ªëi HTTPS!");
        return;
    }
    int httpCode = https.GET();
    if (httpCode == HTTP_CODE_FOUND || httpCode == HTTP_CODE_MOVED_PERMANENTLY) {
        String newURL = https.getLocation();
        Serial.println("‚û°Ô∏è Chuy·ªÉn h∆∞·ªõng ƒë·∫øn: " + newURL);
        https.end();
        if (!https.begin(client, newURL)) return;
        httpCode = https.GET();
    }
    if (httpCode == HTTP_CODE_OK) {
        int contentLength = https.getSize();
        WiFiClient *stream = https.getStreamPtr();
        if (contentLength > 0 && Update.begin(contentLength)) {
            Serial.printf("üì¶ Firmware: %d bytes\n", contentLength);
            size_t written = Update.writeStream(*stream);
            Serial.printf("üìù ƒê√£ ghi: %d bytes\n", written);
            if (written == contentLength && Update.end(true)) {
                Serial.println("‚úÖ C·∫≠p nh·∫≠t th√†nh c√¥ng! Kh·ªüi ƒë·ªông l·∫°i...");
                delay(1000);
                ESP.restart();
            }
        } else {
            Serial.println("‚ùå C·∫≠p nh·∫≠t th·∫•t b·∫°i ho·∫∑c file qu√° l·ªõn!");
        }
    } else {
        Serial.printf("‚ùå L·ªói t·∫£i Firmware, HTTP code: %d\n", httpCode);
    }
    https.end();
}

// ====================== Sinric Handler ======================
// (Gi·ªØ nguy√™n)
bool onPowerState1(const String &deviceId, bool &state) {
    if (!stopAll) {
        Serial.println("‚ö†Ô∏è L·ªánh Sinric Pro b·ªã b·ªè qua do Auto Control ƒëang ch·∫°y!");
        state = state1;
        return false;
    }
    digitalWrite(PIN_1, state);
    state1 = state;
    Serial.printf("[SINRIC] Ch√¢n 4: %s\n", state ? "ON" : "OFF");
    return true;
}

bool onPowerState2(const String &deviceId, bool &state) {
    if (!stopAll) {
        Serial.println("‚ö†Ô∏è L·ªánh Sinric Pro b·ªã b·ªè qua do Auto Control ƒëang ch·∫°y!");
        state = state2;
        return false;
    }
    digitalWrite(PIN_2, state);
    state2 = state;
    Serial.printf("[SINRIC] Ch√¢n 5: %s\n", state ? "ON" : "OFF");
    return true;
}

bool onPowerState3(const String &deviceId, bool &state) {
    if (!stopAll) {
        Serial.println("‚ö†Ô∏è L·ªánh Sinric Pro b·ªã b·ªè qua do Auto Control ƒëang ch·∫°y!");
        state = state3;
        return false;
    }
    digitalWrite(PIN_3, state);
    state3 = state;
    Serial.printf("[SINRIC] Ch√¢n 7: %s\n", state ? "ON" : "OFF");
    return true;
}


// === [M·ªöI] H√ÄM AUTOCONTROL (v7 - 3 Ch√¢n, 3 L·ªãch, H:M:S) ===
void autoControl() {
    if (stopAll) return;

    time_t now;
    time(&now);
    struct tm timeinfo;
    localtime_r(&now, &timeinfo);

    if (timeinfo.tm_year < (2024 - 1900)) {
        return; // Gi·ªù NTP ch∆∞a s·∫µn s√†ng
    }

    // T√≠nh T·ªîNG S·ªê GI√ÇY hi·ªán t·∫°i trong ng√†y
    long currentTimeInSeconds = (timeinfo.tm_hour * 3600) + (timeinfo.tm_min * 60) + timeinfo.tm_sec;

    // --- Logic chung cho l·ªãch h·∫πn gi·ªù (theo T·ªîNG S·ªê GI√ÇY) ---
    auto getTargetState = [&](long startSec, long endSec) {
        if (startSec == endSec) return false; // N·∫øu gi·ªù B·∫≠t = gi·ªù T·∫Øt -> Lu√¥n T·∫ÆT
        
        if (startSec < endSec) {
            // L·ªãch trong ng√†y (v√≠ d·ª•: 10:00:00 - 12:00:00)
            return (currentTimeInSeconds >= startSec) && (currentTimeInSeconds < endSec);
        } else {
            // L·ªãch qua ƒë√™m (v√≠ d·ª•: 22:00:00 - 05:00:00)
            return (currentTimeInSeconds >= startSec) || (currentTimeInSeconds < endSec);
        }
    };

    // --- L·ªãch t·ª± ƒë·ªông cho Ch√¢n 4 (PIN_1) ---
    bool targetState1 = getTargetState(p1_s1_start_s, p1_s1_end_s) ||
                        getTargetState(p1_s2_start_s, p1_s2_end_s) ||
                        getTargetState(p1_s3_start_s, p1_s3_end_s);
                        
    if (targetState1 != state1) {
        state1 = targetState1;
        digitalWrite(PIN_1, state1);
        if (sinricStarted) ((SinricProSwitch&)SinricPro[SWITCH_ID_1]).sendPowerStateEvent(state1);
        Serial.printf("[AUTO] Ch√¢n 4: %s\n", state1 ? "B·∫¨T" : "T·∫ÆT");
    }

    // --- L·ªãch t·ª± ƒë·ªông cho Ch√¢n 5 (PIN_2) ---
    bool targetState2 = getTargetState(p2_s1_start_s, p2_s1_end_s) ||
                        getTargetState(p2_s2_start_s, p2_s2_end_s) ||
                        getTargetState(p2_s3_start_s, p2_s3_end_s);

    if (targetState2 != state2) {
        state2 = targetState2;
        digitalWrite(PIN_2, state2);
        if (sinricStarted) ((SinricProSwitch&)SinricPro[SWITCH_ID_2]).sendPowerStateEvent(state2);
        Serial.printf("[AUTO] Ch√¢n 5: %s\n", state2 ? "B·∫¨T" : "T·∫ÆT");
    }

    // --- L·ªãch t·ª± ƒë·ªông cho Ch√¢n 7 (PIN_3) ---
    bool targetState3 = getTargetState(p3_s1_start_s, p3_s1_end_s) ||
                        getTargetState(p3_s2_start_s, p3_s2_end_s) ||
                        getTargetState(p3_s3_start_s, p3_s3_end_s);

    if (targetState3 != state3) {
        state3 = targetState3;
        digitalWrite(PIN_3, state3);
        if (sinricStarted) ((SinricProSwitch&)SinricPro[SWITCH_ID_3]).sendPowerStateEvent(state3);
        Serial.printf("[AUTO] Ch√¢n 7: %s\n", state3 ? "B·∫¨T" : "T·∫ÆT");
    }

    // --- Ch√¢n 16 (PIN_4) KH√îNG C√ì L·ªäCH AUTO ---
    // (n√≥ s·∫Ω gi·ªØ nguy√™n tr·∫°ng th√°i do ng∆∞·ªùi d√πng b·∫≠t/t·∫Øt tay)
}


// === T√ÅC V·ª§ L√ïI 0 (Gi·ªØ nguy√™n logic v5) ===
void networkTask(void *pvParameters) {
    Serial.println("[TASK] T√°c v·ª• M·∫°ng ƒë√£ kh·ªüi ƒë·ªông tr√™n L√µi 0.");
    initTime(); 

    unsigned long lastNtpCheck = 0;
    unsigned long lastAutoControl = 0;

    for (;;) { 
        if (WiFi.status() != WL_CONNECTED) {
            if (sinricStarted) {
                Serial.println("[TASK] M·∫•t WiFi. T·∫°m d·ª´ng Sinric/NTP.");
                sinricStarted = false; 
                isInternetActive = false;
            }
            vTaskDelay(1000 / portTICK_PERIOD_MS); 
            continue; 
        }

        if (!isInternetActive || (millis() - lastNtpCheck > 10000)) { 
            Serial.println("[TASK] C√≥ WiFi, ƒëang ki·ªÉm tra Internet (NTP)...");
            struct tm timeinfo;
            if (getLocalTime(&timeinfo, 2000)) { 
                if (!isInternetActive) {
                    Serial.printf("[TASK] ‚úÖ ƒê√£ ƒë·ªìng b·ªô gi·ªù NTP: %02d:%02d:%02d\n", timeinfo.tm_hour, timeinfo.tm_min, timeinfo.tm_sec);
                    isInternetActive = true; 
                }
            } else {
                Serial.println("[TASK] ‚ùå NTP th·∫•t b·∫°i (ch∆∞a c√≥ Internet).");
                isInternetActive = false;
            }
            lastNtpCheck = millis(); 
        }

        if (isInternetActive && !sinricStarted) {
            Serial.println("[TASK] C√≥ th·ªùi gian, ƒëang th·ª≠ SinricPro.begin()...");
            SinricPro.begin(APP_KEY, APP_SECRET);
            Serial.println("[TASK] SinricPro.begin() ƒë√£ ch·∫°y xong.");
            sinricStarted = true;
        }

        if (sinricStarted) {
            SinricPro.handle();
        }

        // Ch·∫°y autoControl 1 gi√¢y 1 l·∫ßn
        if (isInternetActive && (millis() - lastAutoControl > 1000)) {
            autoControl(); // G·ªçi h√†m autoControl (v7) m·ªõi
            lastAutoControl = millis();
        }
        
        vTaskDelay(50 / portTICK_PERIOD_MS);
    }
}
// ===================================


// ====================== SETUP ======================
void setup() {
    Serial.begin(115200);

    loadState(); // T·∫£i tr·∫°ng th√°i D·ª´ng/Ch·∫°y
    loadSchedules(); // [M·ªöI] T·∫£i l·ªãch h·∫πn gi·ªù H:M:S ƒë√£ l∆∞u

    prefs.begin(PREF_NAMESPACE, true);
    saved_ssid = prefs.getString(KEY_WIFI_SSID, "");
    saved_pass = prefs.getString(KEY_WIFI_PASS, "");
    prefs.end();

    pinMode(PIN_1, OUTPUT); digitalWrite(PIN_1, LOW);
    pinMode(PIN_2, OUTPUT); digitalWrite(PIN_2, LOW);
    pinMode(PIN_3, OUTPUT); digitalWrite(PIN_3, LOW);
    pinMode(PIN_4, OUTPUT); digitalWrite(PIN_4, LOW);
    pinMode(PIN_STOP, INPUT_PULLUP);
    pinMode(PIN_RESET, INPUT_PULLUP);
    pinMode(PIN_OTA, INPUT_PULLUP);

    state1 = state2 = state3 = state4 = LOW;
    startTime = millis();

    WiFi.mode(WIFI_AP_STA);
    WiFi.softAP(ap_ssid, ap_pass);
    delay(100);
    dns.start(53, "*", WiFi.softAPIP());
    Serial.println("‚úÖ AP ƒë√£ kh·ªüi ƒë·ªông: " + String(ap_ssid));
    Serial.print("IP AP: "); Serial.println(WiFi.softAPIP());

    if (saved_ssid.length() > 0) {
        Serial.printf("üì° ƒêang k·∫øt n·ªëi ƒë·∫øn WiFi ƒë√£ l∆∞u: %s\n", saved_ssid.c_str());
        WiFi.begin(saved_ssid.c_str(), saved_pass.c_str());
        unsigned long t = millis();
        while (WiFi.status() != WL_CONNECTED && millis() - t < 10000) {
            delay(500);
            Serial.print(".");
        }
        Serial.println();
        if (WiFi.status() == WL_CONNECTED) {
            Serial.println("‚úÖ K·∫øt n·ªëi WiFi th√†nh c√¥ng!");
            Serial.print("IP LAN: "); Serial.println(WiFi.localIP());
        } else {
            Serial.println("‚ùå K·∫øt n·ªëi WiFi th·∫•t b·∫°i! Ch·ªâ ch·∫°y AP.");
        }
    } else {
        Serial.println("‚ÑπÔ∏è Ch∆∞a c√≥ WiFi n√†o ƒë∆∞·ª£c l∆∞u. Ch·ªâ ch·∫°y AP.");
    }

    // Khai b√°o Web Server Handlers (CH·∫†Y TR√äN L√ïI 1)
    server.on("/", [](){ server.send(200, "text/html", htmlPage()); });

    // === [M·ªöI] TH√äM HANDLER CHO TRANG H·∫∏N GI·ªú (v7) ===
    server.on("/hengio", HTTP_GET, handleSchedulePage);
    server.on("/save_hengio", HTTP_POST, handleSaveSchedule);
    // ================================================

    // Toggle 1
    server.on("/toggle1", [](){
        if (stopAll) { // Ch·ªâ cho ph√©p ƒëi·ªÅu khi·ªÉn tay khi Auto D·ª™NG
            state1 = !state1; digitalWrite(PIN_1, state1);
            if(sinricStarted) ((SinricProSwitch&)SinricPro[SWITCH_ID_1]).sendPowerStateEvent(state1);
        }
        server.sendHeader("Location", "/"); server.send(303);
    });
    // Toggle 2
    server.on("/toggle2", [](){
        if (stopAll) {
            state2 = !state2; digitalWrite(PIN_2, state2);
            if(sinricStarted) ((SinricProSwitch&)SinricPro[SWITCH_ID_2]).sendPowerStateEvent(state2);
        }
        server.sendHeader("Location", "/"); server.send(303);
    });
    // Toggle 3
    server.on("/toggle3", [](){
        if (stopAll) {
            state3 = !state3; digitalWrite(PIN_3, state3);
            if(sinricStarted) ((SinricProSwitch&)SinricPro[SWITCH_ID_3]).sendPowerStateEvent(state3);
        }
        server.sendHeader("Location", "/"); server.send(303);
    });
    
    // Toggle 4 (Ch√¢n 16) - Lu√¥n ƒëi·ªÅu khi·ªÉn tay ƒë∆∞·ª£c (n·∫øu stopAll)
    server.on("/toggle4", [](){
        if (stopAll) {
            state4 = !state4;
            digitalWrite(PIN_4, state4);
            Serial.printf("[WEB] Ch√¢n 16 (PIN_4) ƒë√£ chuy·ªÉn sang: %s\n", state4 ? "ON" : "OFF");
        } else {
            Serial.println("[WEB] Ch√¢n 16 b·ªã ch·∫∑n do Auto Control ƒëang ch·∫°y!");
        }
        server.sendHeader("Location", "/"); server.send(303);
    });

    // C√°c n√∫t control
    server.on("/toggleStop", [](){
        stopAll = !stopAll;
        saveState();
        server.sendHeader("Location", "/"); server.send(303);
    });
    server.on("/resetAuto", [](){
        startTime = millis();
        stopAll = false;
        saveState();
        server.sendHeader("Location", "/"); server.send(303);
    });
    server.on("/otaUpdate", [](){ server.send(200, "text/html", "<h3>ƒêang c·∫≠p nh·∫≠t firmware...</h3>"); performOTA(); });

    // C√°c handler WiFi
    server.on("/wifi", HTTP_GET, handleWifiSettings); 
    server.on("/wifi_scan_results", HTTP_GET, handleWifiScanResults); 
    server.on("/savewifi", HTTP_POST, handleSaveWifi); 

    // Captive Portal
    server.onNotFound([]() {
        if (WiFi.status() != WL_CONNECTED && saved_ssid.length() == 0) {
             server.sendHeader("Location", "http://" + WiFi.softAPIP().toString() + "/wifi", true);
             server.send(302, "text/plain", "");
        } else {
             server.sendHeader("Location", "http://" + WiFi.softAPIP().toString() + "/", true);
             server.send(302, "text/plain", "");
        }
    });

    server.begin();

    // SinricPro setup
    SinricProSwitch &device1 = SinricPro[SWITCH_ID_1];
    SinricProSwitch &device2 = SinricPro[SWITCH_ID_2];
    SinricProSwitch &device3 = SinricPro[SWITCH_ID_3];
    device1.onPowerState(onPowerState1);
    device2.onPowerState(onPowerState2);
    device3.onPowerState(onPowerState3);

    Serial.println("‚úÖ ESP32-S3 (v7) ƒë√£ kh·ªüi ƒë·ªông ho√†n t·∫•t! Web Server ƒëang ch·∫°y tr√™n L√µi 1.");

    // === KH·ªûI ƒê·ªòNG T√ÅC V·ª§ L√ïI 0 ===
    xTaskCreatePinnedToCore(
        networkTask,        /* H√†m ƒë·ªÉ ch·∫°y Task */
        "NetworkTask",      /* T√™n c·ªßa Task (ƒë·ªÉ debug) */
        12000,              /* K√≠ch th∆∞·ªõc Stack */
        NULL,               /* Tham s·ªë ƒë·∫ßu v√†o cho Task */
        1,                  /* ∆Øu ti√™n (priority) */
        &NetworkTaskHandle, /* Handle c·ªßa Task */
        0                   /* Ghim v√†o L√µi 0 (Core 0) */
    );
}

// ====================== LOOP (L√ïI 1 - SI√äU NHANH) ======================
void loop() {
    dns.processNextRequest();
    server.handleClient();

    unsigned long now = millis();
    bool stateChanged = false;

    // N√∫t D·ª™NG Auto (PIN_STOP - GPIO 8)
    if (digitalRead(PIN_STOP) == LOW) {
        if (now - lastStopButtonTime > DEBOUNCE_DELAY) {
            if (!stopAll) {
                stopAll = true;
                stateChanged = true;
                Serial.println("[BUTTON] Auto Control D·ª™NG (PIN_STOP)");
            }
        }
        lastStopButtonTime = now;
    }

    // N√∫t KH·ªûI ƒê·ªòNG/B·∫¨T Auto (PIN_RESET - GPIO 9)
    if (digitalRead(PIN_RESET) == LOW) {
        if (now - lastResetButtonTime > DEBOUNCE_DELAY) {
            if (stopAll) {
                startTime = now;
                stopAll = false;
                stateChanged = true;
                Serial.println("[BUTTON] Auto Control B·∫¨T (PIN_RESET)");
            }
        }
        lastResetButtonTime = now;
    }

    if (stateChanged) {
        saveState();
    }

    // N√∫t OTA
    if (digitalRead(PIN_OTA) == LOW) {
      if (WiFi.status() == WL_CONNECTED) {
        performOTA(); 
      } else {
        Serial.println("Nh·∫•n OTA nh∆∞ng kh√¥ng c√≥ WiFi!");
      }
    }
}
